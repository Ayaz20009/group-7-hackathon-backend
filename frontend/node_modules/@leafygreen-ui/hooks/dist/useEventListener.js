var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { useEffect, useRef } from 'react';
/**
 * Hook to subscribe to an event listener.
 * @param type Represents the event type to listen for.
 * @param eventCallback Event listener callback function.
 * @param optional Optional third argument passed to function with implementation specifications
 * @param optional.options Parameter to specify options passed to the eventListener.
 * @param optional.enabled Determines whether or not the useEffect hook should run.
 * @param optional.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.
 * @param optional.element Value to be passed as target of event handler, will default to document.
 */
export default function useEventListener(type, eventCallback, _a) {
    var _b = _a === void 0 ? {} : _a, options = _b.options, _c = _b.enabled, enabled = _c === void 0 ? true : _c, _d = _b.dependencies, dependencies = _d === void 0 ? [enabled, type] : _d, element = _b.element;
    var memoizedEventCallback = useRef(function () { });
    useEffect(function () {
        memoizedEventCallback.current = eventCallback;
    }, [eventCallback]);
    useEffect(function () {
        if (enabled === false) {
            return;
        }
        // Handle this in case non-TypeScript users pass in the wrong value
        if (enabled !== 'once' && enabled !== true) {
            console.error("Received value of type " + typeof enabled + " for property `enabled`. Expected a boolean.");
            return;
        }
        var callback = function (e) {
            return memoizedEventCallback.current(e);
        };
        var eventListenerOptions = __assign(__assign({}, options), { once: enabled === 'once' });
        // NOTE(JeT): I'm pretty sure there should be a way to avoid this type assertion, but I couldn't figure it out.
        (element !== null && element !== void 0 ? element : document).addEventListener(type, callback, eventListenerOptions);
        return function () {
            (element !== null && element !== void 0 ? element : document).removeEventListener(type, callback, eventListenerOptions);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}
//# sourceMappingURL=useEventListener.js.map