import { useState, useRef, useEffect } from 'react';
import useEventListener from './useEventListener';
function useVisibilityChange() {
    var isVisibilityStateVisible = function () { return document.visibilityState === 'visible'; };
    var _a = useState(true), isVisible = _a[0], setIsVisible = _a[1];
    useEffect(function () {
        setIsVisible(isVisibilityStateVisible);
    }, []);
    useEventListener('visibilitychange', function () {
        setIsVisible(isVisibilityStateVisible);
    });
    return isVisible;
}
export default function usePoller(onPoll, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.interval, interval = _c === void 0 ? 30e3 : _c, _d = _b.immediate, immediate = _d === void 0 ? true : _d, _e = _b.enabled, enabled = _e === void 0 ? true : _e;
    var savedCallback = useRef();
    var isVisible = useVisibilityChange();
    var isPolling = isVisible && enabled;
    useEffect(function () {
        savedCallback.current = onPoll;
    });
    useEffect(function () {
        if (!isPolling) {
            return;
        }
        // Using this reflection to get return type of setTimeout so we don't have to
        // use window.setTimeout, makes this more cross-environment compatible
        // Sourced from: https://stackoverflow.com/a/51040768
        var id;
        function scheduleNextPoll() {
            unscheduleNextPoll();
            id = setTimeout(poll, interval);
        }
        function unscheduleNextPoll() {
            clearTimeout(id);
        }
        function poll() {
            var _a;
            Promise.resolve((_a = savedCallback.current) === null || _a === void 0 ? void 0 : _a.call(savedCallback)).finally(scheduleNextPoll);
        }
        if (immediate) {
            poll();
        }
        else {
            scheduleNextPoll();
        }
        return unscheduleNextPoll;
    }, [interval, immediate, isPolling]);
}
//# sourceMappingURL=usePoller.js.map